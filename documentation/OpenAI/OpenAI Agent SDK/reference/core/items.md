---
title: `Items`
source: https://openai.github.io/openai-agents-python/ref/items/
---

# `Items`

### TResponse`module-attribute`

```
TResponse = Response

```

A type alias for the Response type from the OpenAI SDK.

### TResponseInputItem`module-attribute`

```
TResponseInputItem = ResponseInputItemParam

```

A type alias for the ResponseInputItemParam type from the OpenAI SDK.

### TResponseOutputItem`module-attribute`

```
TResponseOutputItem = ResponseOutputItem

```

A type alias for the ResponseOutputItem type from the OpenAI SDK.

### TResponseStreamEvent`module-attribute`

```
TResponseStreamEvent = ResponseStreamEvent

```

A type alias for the ResponseStreamEvent type from the OpenAI SDK.

### ToolCallItemTypes`module-attribute`

```
ToolCallItemTypes: TypeAlias = Union[\
    ResponseFunctionToolCall,\
    ResponseComputerToolCall,\
    ResponseFileSearchToolCall,\
    ResponseFunctionWebSearch,\
    McpCall,\
    ResponseCodeInterpreterToolCall,\
    ImageGenerationCall,\
    LocalShellCall,\
]

```

A type that represents a tool call item.

### RunItem`module-attribute`

```
RunItem: TypeAlias = Union[\
    MessageOutputItem,\
    HandoffCallItem,\
    HandoffOutputItem,\
    ToolCallItem,\
    ToolCallOutputItem,\
    ReasoningItem,\
    MCPListToolsItem,\
    MCPApprovalRequestItem,\
    MCPApprovalResponseItem,\
]

```

An item generated by an agent.

### RunItemBase`dataclass`

Bases: `Generic[T]`, `ABC`

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```636465666768697071727374757677787980818283``` | ```md-code__content@dataclassclass RunItemBase(Generic[T], abc.ABC):    agent: Agent[Any]    """The agent whose run caused this item to be generated."""    raw_item: T    """The raw Responses item from the run. This will always be a either an output item (i.e.    `openai.types.responses.ResponseOutputItem` or an input item    (i.e. `openai.types.responses.ResponseInputItemParam`).    """    def to_input_item(self) -> TResponseInputItem:        """Converts this item into an input item suitable for passing to the model."""        if isinstance(self.raw_item, dict):            # We know that input items are dicts, so we can ignore the type error            return self.raw_item  # type: ignore        elif isinstance(self.raw_item, BaseModel):            # All output items are Pydantic models that can be converted to input items.            return self.raw_item.model_dump(exclude_unset=True)  # type: ignore        else:            raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### raw\_item`instance-attribute`

```
raw_item: T

```

The raw Responses item from the run. This will always be a either an output item (i.e.
`openai.types.responses.ResponseOutputItem` or an input item
(i.e. `openai.types.responses.ResponseInputItemParam`).

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### MessageOutputItem`dataclass`

Bases: `RunItemBase[ResponseOutputMessage]`

Represents a message from the LLM.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```8687888990919293``` | ```md-code__content@dataclassclass MessageOutputItem(RunItemBase[ResponseOutputMessage]):    """Represents a message from the LLM."""    raw_item: ResponseOutputMessage    """The raw response output message."""    type: Literal["message_output_item"] = "message_output_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: ResponseOutputMessage

```

The raw response output message.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### HandoffCallItem`dataclass`

Bases: `RunItemBase[ResponseFunctionToolCall]`

Represents a tool call for a handoff from one agent to another.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ``` 96 97 98 99100101102103``` | ```md-code__content@dataclassclass HandoffCallItem(RunItemBase[ResponseFunctionToolCall]):    """Represents a tool call for a handoff from one agent to another."""    raw_item: ResponseFunctionToolCall    """The raw response function tool call that represents the handoff."""    type: Literal["handoff_call_item"] = "handoff_call_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: ResponseFunctionToolCall

```

The raw response function tool call that represents the handoff.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### HandoffOutputItem`dataclass`

Bases: `RunItemBase[TResponseInputItem]`

Represents the output of a handoff.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```106107108109110111112113114115116117118119``` | ```md-code__content@dataclassclass HandoffOutputItem(RunItemBase[TResponseInputItem]):    """Represents the output of a handoff."""    raw_item: TResponseInputItem    """The raw input item that represents the handoff taking place."""    source_agent: Agent[Any]    """The agent that made the handoff."""    target_agent: Agent[Any]    """The agent that is being handed off to."""    type: Literal["handoff_output_item"] = "handoff_output_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: TResponseInputItem

```

The raw input item that represents the handoff taking place.

#### source\_agent`instance-attribute`

```
source_agent: Agent[Any]

```

The agent that made the handoff.

#### target\_agent`instance-attribute`

```
target_agent: Agent[Any]

```

The agent that is being handed off to.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### ToolCallItem`dataclass`

Bases: `RunItemBase[ToolCallItemTypes]`

Represents a tool call e.g. a function call or computer action call.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```135136137138139140141142``` | ```md-code__content@dataclassclass ToolCallItem(RunItemBase[ToolCallItemTypes]):    """Represents a tool call e.g. a function call or computer action call."""    raw_item: ToolCallItemTypes    """The raw tool call item."""    type: Literal["tool_call_item"] = "tool_call_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: ToolCallItemTypes

```

The raw tool call item.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### ToolCallOutputItem`dataclass`

Bases: `RunItemBase[Union[FunctionCallOutput, ComputerCallOutput, LocalShellCallOutput]]`

Represents the output of a tool call.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```145146147148149150151152153154155156157158159``` | ```md-code__content@dataclassclass ToolCallOutputItem(    RunItemBase[Union[FunctionCallOutput, ComputerCallOutput, LocalShellCallOutput]]):    """Represents the output of a tool call."""    raw_item: FunctionCallOutput | ComputerCallOutput | LocalShellCallOutput    """The raw item from the model."""    output: Any    """The output of the tool call. This is whatever the tool call returned; the `raw_item`    contains a string representation of the output.    """    type: Literal["tool_call_output_item"] = "tool_call_output_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: (
    FunctionCallOutput
    | ComputerCallOutput
    | LocalShellCallOutput
)

```

The raw item from the model.

#### output`instance-attribute`

```
output: Any

```

The output of the tool call. This is whatever the tool call returned; the `raw_item`
contains a string representation of the output.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### ReasoningItem`dataclass`

Bases: `RunItemBase[ResponseReasoningItem]`

Represents a reasoning item.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```162163164165166167168169``` | ```md-code__content@dataclassclass ReasoningItem(RunItemBase[ResponseReasoningItem]):    """Represents a reasoning item."""    raw_item: ResponseReasoningItem    """The raw reasoning item."""    type: Literal["reasoning_item"] = "reasoning_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: ResponseReasoningItem

```

The raw reasoning item.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### MCPListToolsItem`dataclass`

Bases: `RunItemBase[McpListTools]`

Represents a call to an MCP server to list tools.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```172173174175176177178179``` | ```md-code__content@dataclassclass MCPListToolsItem(RunItemBase[McpListTools]):    """Represents a call to an MCP server to list tools."""    raw_item: McpListTools    """The raw MCP list tools call."""    type: Literal["mcp_list_tools_item"] = "mcp_list_tools_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: McpListTools

```

The raw MCP list tools call.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### MCPApprovalRequestItem`dataclass`

Bases: `RunItemBase[McpApprovalRequest]`

Represents a request for MCP approval.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```182183184185186187188189``` | ```md-code__content@dataclassclass MCPApprovalRequestItem(RunItemBase[McpApprovalRequest]):    """Represents a request for MCP approval."""    raw_item: McpApprovalRequest    """The raw MCP approval request."""    type: Literal["mcp_approval_request_item"] = "mcp_approval_request_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: McpApprovalRequest

```

The raw MCP approval request.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### MCPApprovalResponseItem`dataclass`

Bases: `RunItemBase[McpApprovalResponse]`

Represents a response to an MCP approval request.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```192193194195196197198199``` | ```md-code__content@dataclassclass MCPApprovalResponseItem(RunItemBase[McpApprovalResponse]):    """Represents a response to an MCP approval request."""    raw_item: McpApprovalResponse    """The raw MCP approval response."""    type: Literal["mcp_approval_response_item"] = "mcp_approval_response_item"``` |

#### raw\_item`instance-attribute`

```
raw_item: McpApprovalResponse

```

The raw MCP approval response.

#### agent`instance-attribute`

```
agent: Agent[Any]

```

The agent whose run caused this item to be generated.

#### to\_input\_item

```
to_input_item() -> TResponseInputItem

```

Converts this item into an input item suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```74757677787980818283``` | ```md-code__contentdef to_input_item(self) -> TResponseInputItem:    """Converts this item into an input item suitable for passing to the model."""    if isinstance(self.raw_item, dict):        # We know that input items are dicts, so we can ignore the type error        return self.raw_item  # type: ignore    elif isinstance(self.raw_item, BaseModel):        # All output items are Pydantic models that can be converted to input items.        return self.raw_item.model_dump(exclude_unset=True)  # type: ignore    else:        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")``` |

### ModelResponse

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```216217218219220221222223224225226227228229230231232233234235236``` | ```md-code__content@pydantic.dataclasses.dataclassclass ModelResponse:    output: list[TResponseOutputItem]    """A list of outputs (messages, tool calls, etc) generated by the model"""    usage: Usage    """The usage information for the response."""    response_id: str | None    """An ID for the response which can be used to refer to the response in subsequent calls to the    model. Not supported by all model providers.    If using OpenAI models via the Responses API, this is the `response_id` parameter, and it can    be passed to `Runner.run`.    """    def to_input_items(self) -> list[TResponseInputItem]:        """Convert the output into a list of input items suitable for passing to the model."""        # We happen to know that the shape of the Pydantic output items are the same as the        # equivalent TypedDict input items, so we can just convert each one.        # This is also tested via unit tests.        return [it.model_dump(exclude_unset=True) for it in self.output]  # type: ignore``` |

#### output`instance-attribute`

```
output: list[TResponseOutputItem]

```

A list of outputs (messages, tool calls, etc) generated by the model

#### usage`instance-attribute`

```
usage: Usage

```

The usage information for the response.

#### response\_id`instance-attribute`

```
response_id: str | None

```

An ID for the response which can be used to refer to the response in subsequent calls to the
model. Not supported by all model providers.
If using OpenAI models via the Responses API, this is the `response_id` parameter, and it can
be passed to `Runner.run`.

#### to\_input\_items

```
to_input_items() -> list[TResponseInputItem]

```

Convert the output into a list of input items suitable for passing to the model.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```231232233234235236``` | ```md-code__contentdef to_input_items(self) -> list[TResponseInputItem]:    """Convert the output into a list of input items suitable for passing to the model."""    # We happen to know that the shape of the Pydantic output items are the same as the    # equivalent TypedDict input items, so we can just convert each one.    # This is also tested via unit tests.    return [it.model_dump(exclude_unset=True) for it in self.output]  # type: ignore``` |

### ItemHelpers

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305``` | ```md-code__contentclass ItemHelpers:    @classmethod    def extract_last_content(cls, message: TResponseOutputItem) -> str:        """Extracts the last text content or refusal from a message."""        if not isinstance(message, ResponseOutputMessage):            return ""        last_content = message.content[-1]        if isinstance(last_content, ResponseOutputText):            return last_content.text        elif isinstance(last_content, ResponseOutputRefusal):            return last_content.refusal        else:            raise ModelBehaviorError(f"Unexpected content type: {type(last_content)}")    @classmethod    def extract_last_text(cls, message: TResponseOutputItem) -> str | None:        """Extracts the last text content from a message, if any. Ignores refusals."""        if isinstance(message, ResponseOutputMessage):            last_content = message.content[-1]            if isinstance(last_content, ResponseOutputText):                return last_content.text        return None    @classmethod    def input_to_new_input_list(        cls, input: str | list[TResponseInputItem]    ) -> list[TResponseInputItem]:        """Converts a string or list of input items into a list of input items."""        if isinstance(input, str):            return [                {                    "content": input,                    "role": "user",                }            ]        return copy.deepcopy(input)    @classmethod    def text_message_outputs(cls, items: list[RunItem]) -> str:        """Concatenates all the text content from a list of message output items."""        text = ""        for item in items:            if isinstance(item, MessageOutputItem):                text += cls.text_message_output(item)        return text    @classmethod    def text_message_output(cls, message: MessageOutputItem) -> str:        """Extracts all the text content from a single message output item."""        text = ""        for item in message.raw_item.content:            if isinstance(item, ResponseOutputText):                text += item.text        return text    @classmethod    def tool_call_output_item(        cls, tool_call: ResponseFunctionToolCall, output: str    ) -> FunctionCallOutput:        """Creates a tool call output item from a tool call and its output."""        return {            "call_id": tool_call.call_id,            "output": output,            "type": "function_call_output",        }``` |

#### extract\_last\_content`classmethod`

```
extract_last_content(message: TResponseOutputItem) -> str

```

Extracts the last text content or refusal from a message.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```240241242243244245246247248249250251252``` | ```md-code__content@classmethoddef extract_last_content(cls, message: TResponseOutputItem) -> str:    """Extracts the last text content or refusal from a message."""    if not isinstance(message, ResponseOutputMessage):        return ""    last_content = message.content[-1]    if isinstance(last_content, ResponseOutputText):        return last_content.text    elif isinstance(last_content, ResponseOutputRefusal):        return last_content.refusal    else:        raise ModelBehaviorError(f"Unexpected content type: {type(last_content)}")``` |

#### extract\_last\_text`classmethod`

```
extract_last_text(
    message: TResponseOutputItem,
) -> str | None

```

Extracts the last text content from a message, if any. Ignores refusals.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```254255256257258259260261262``` | ```md-code__content@classmethoddef extract_last_text(cls, message: TResponseOutputItem) -> str | None:    """Extracts the last text content from a message, if any. Ignores refusals."""    if isinstance(message, ResponseOutputMessage):        last_content = message.content[-1]        if isinstance(last_content, ResponseOutputText):            return last_content.text    return None``` |

#### input\_to\_new\_input\_list`classmethod`

```
input_to_new_input_list(
    input: str | list[TResponseInputItem],
) -> list[TResponseInputItem]

```

Converts a string or list of input items into a list of input items.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```264265266267268269270271272273274275276``` | ```md-code__content@classmethoddef input_to_new_input_list(    cls, input: str | list[TResponseInputItem]) -> list[TResponseInputItem]:    """Converts a string or list of input items into a list of input items."""    if isinstance(input, str):        return [            {                "content": input,                "role": "user",            }        ]    return copy.deepcopy(input)``` |

#### text\_message\_outputs`classmethod`

```
text_message_outputs(items: list[RunItem]) -> str

```

Concatenates all the text content from a list of message output items.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```278279280281282283284285``` | ```md-code__content@classmethoddef text_message_outputs(cls, items: list[RunItem]) -> str:    """Concatenates all the text content from a list of message output items."""    text = ""    for item in items:        if isinstance(item, MessageOutputItem):            text += cls.text_message_output(item)    return text``` |

#### text\_message\_output`classmethod`

```
text_message_output(message: MessageOutputItem) -> str

```

Extracts all the text content from a single message output item.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```287288289290291292293294``` | ```md-code__content@classmethoddef text_message_output(cls, message: MessageOutputItem) -> str:    """Extracts all the text content from a single message output item."""    text = ""    for item in message.raw_item.content:        if isinstance(item, ResponseOutputText):            text += item.text    return text``` |

#### tool\_call\_output\_item`classmethod`

```
tool_call_output_item(
    tool_call: ResponseFunctionToolCall, output: str
) -> FunctionCallOutput

```

Creates a tool call output item from a tool call and its output.

Source code in `src/agents/items.py`

|  |  |
| --- | --- |
| ```296297298299300301302303304305``` | ```md-code__content@classmethoddef tool_call_output_item(    cls, tool_call: ResponseFunctionToolCall, output: str) -> FunctionCallOutput:    """Creates a tool call output item from a tool call and its output."""    return {        "call_id": tool_call.call_id,        "output": output,        "type": "function_call_output",    }``` |