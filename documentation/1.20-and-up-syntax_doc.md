# From NBT to Components: The 2025 Creator’s Field Guide to Java-Bedrock Parity

## Executive Summary

The creator ecosystems for Minecraft: Java Edition and Bedrock Edition, particularly since version 1.20, are diverging based on a fundamental philosophical split in data management. Java Edition has historically championed flexible, arbitrary data introspection through its Named Binary Tag (NBT) format, allowing creators to read and write almost any game data at runtime with powerful commands like `/data`. [executive_summary[1]][1] While Java 1.20.5 initiated a major shift towards structured 'Data Components' for items, the core principle of powerful command-line introspection remains, with `minecraft:custom_data` as an escape hatch for custom data. [executive_summary[0]][2]

In stark contrast, Bedrock Edition enforces a stricter, validated, and component-based architecture. It completely avoids arbitrary NBT manipulation, instead providing creators with two primary systems for managing state: predefined, type-safe 'Entity Properties' declared in behavior packs, and a flexible 'Dynamic Properties' store managed exclusively through the Script API. [executive_summary[2]][3] [executive_summary[3]][4] This means porting content is not a direct translation but a re-architecting process, moving from Java's command-centric, data-flexible world to Bedrock's event-driven, component-and-script-oriented framework.

### Key Differences at a Glance: Data Model & State Management

| Feature Category | Java Edition Summary | Bedrock Edition Summary | Primary Implication for Creators |
| :--- | :--- | :--- | :--- |
| **Data Model & State Management** | Utilizes a flexible NBT (Named Binary Tag) system for most game data, which can be directly read and manipulated at runtime via the powerful `/data` command and `execute if data`. [key_differences_at_a_glance.java_edition_summary[0]][2] Since version 1.20.5, items have transitioned to a structured, typed 'Data Component' system, with the `minecraft:custom_data` component serving as the container for arbitrary creator data. [key_differences_at_a_glance.java_edition_summary[0]][2] | Employs a strict, JSON-defined component model. [key_differences_at_a_glance.bedrock_edition_summary[0]][3] Custom state is managed through two primary systems: predefined, type-safe 'Entity Properties' (int, float, bool, enum) declared in behavior packs, and a flexible 'Dynamic Properties' key-value store (string, number, boolean) that is exclusively managed via the Script API. [key_differences_at_a_glance.bedrock_edition_summary[0]][3] [key_differences_at_a_glance.bedrock_edition_summary[1]][4] [key_differences_at_a_glance.bedrock_edition_summary[2]][5] | Java offers unparalleled runtime data flexibility and introspection through commands, allowing for complex logic within data packs. [key_differences_at_a_glance.primary_implication_for_creators[0]][2] Bedrock enforces a more structured, validated, and often more performant system that requires creators to work within its component and scripting frameworks, trading some command-line power for reliability and better client-side integration. [key_differences_at_a_glance.primary_implication_for_creators[1]][3] [key_differences_at_a_glance.primary_implication_for_creators[2]][5] [key_differences_at_a_glance.primary_implication_for_creators[3]][4] |

### The Most Critical Breaking Changes for Creators

* **Java 1.21 Folder Renames:** A seemingly minor change—renaming data pack directories like `functions/` to `function/`—breaks all pre-1.21 packs, forcing creators to maintain separate builds or use pack overlays.
* **Java 1.20.5 Item Component Migration:** The replacement of item NBT with structured components is a fundamental shift. Commands like `/give` and `/item` now use a new `item[component=...]` syntax, and all custom data must be migrated to the `minecraft:custom_data` component. [data_model_and_architecture_comparison[7]][6] [data_model_and_architecture_comparison[8]][7]
* **Bedrock 1.21.20 'Holiday Creator Features' Removal:** This experimental toggle was completely removed, breaking any content that relied on it. The official migration path is to the now-stable Custom Components system, requiring a significant rewrite of entity behaviors. [bedrock_edition_version_changelog.deprecations_and_migrations[3]][8] [bedrock_edition_version_changelog.deprecations_and_migrations[4]][9]

### The Parity Illusion: Where Commands Diverge

While Bedrock's `/execute` command now mirrors Java's syntax, it lacks critical features. The most significant omission is the `store` subcommand, which prevents command-only systems from dynamically capturing and using data like entity positions or item counts. [command_parity_execute.missing_subcommands_in_bedrock[0]][10] Similarly, Bedrock has no equivalent to Java's `/data` command for NBT inspection, forcing creators to re-architect logic around Bedrock's property and scripting systems. [command_parity_data_introspection.java_capabilities[0]][1]

## 1. Philosophical Split—Arbitrary NBT vs. Typed Components

The core architectural difference between Java and Bedrock for creators is a philosophical one: Java prioritizes flexible, arbitrary data access, while Bedrock enforces a structured, validated, and performant component model. This choice dictates everything from how you store an entity's "mana" to how you build conditional logic, and understanding it is the key to successful cross-edition development.

### 1.1 Data Models Side-by-Side: NBT, Components, and Properties

Java Edition has historically been built on the Named Binary Tag (NBT) format, a hierarchical data structure used for almost all game data. [data_model_and_architecture_comparison[1]][11] This allowed creators to use the `/data` command to directly read and write almost any data on entities and blocks at runtime. [command_parity_data_introspection.java_capabilities[0]][1] The major technical update in version **1.20.5** began a shift away from this model for items, replacing the unstructured `tag` with a system of typed, validated **Data Components**. [data_model_and_architecture_comparison[7]][6] [data_model_and_architecture_comparison[8]][7] However, the spirit of arbitrary data remains, with the `minecraft:custom_data` component serving as the official container for any creator-defined NBT. [data_model_and_architecture_comparison.primary_system[1]][6]

Bedrock Edition, by contrast, uses a multi-layered, strictly defined system. It has no equivalent to Java's `/data` command for NBT manipulation. Instead, state is managed through:
* **JSON-defined Components:** The primary method for defining the behavior of custom items, blocks, and entities in Behavior Packs. [data_model_and_architecture_comparison[39]][12]
* **Entity Properties:** Predefined, type-safe data fields (`int`, `float`, `bool`, `enum`) declared in an entity's JSON file. These values persist with the entity and can be synced to the client for rendering and animation. [data_model_and_architecture_comparison.primary_system[2]][4]
* **Dynamic Properties:** A flexible key-value store (`string`, `number`, `boolean`, `Vector3`) managed exclusively through the Script API. These are designed for cross-session persistence and are the closest Bedrock equivalent to Java's command storage. [data_model_and_architecture_comparison[5]][13] [data_model_and_architecture_comparison[6]][14]

| Aspect | Java Edition (1.20.5+) | Bedrock Edition (1.20+) |
| :--- | :--- | :--- |
| **Primary System** | Evolved from universal NBT to a hybrid system. Items use structured **Data Components**, while entities and blocks retain NBT. [data_model_and_architecture_comparison.primary_system[0]][2] | Multi-layered system of **JSON Components**, **Entity Properties**, and script-managed **Dynamic Properties**. [data_model_and_architecture_comparison.primary_system[2]][4] |
| **Access Method** | Command-driven via `/data` (get, modify, merge, remove) and `/execute store`. [data_model_and_architecture_comparison.access_methods[0]][1] | Integrated toolset: **Molang** (`query.property`), **entity events** (`set_property`), **filters** (`has_property`), and **Script API** (`getProperty`, `setDynamicProperty`). [data_model_and_architecture_comparison.access_methods[1]][4] [data_model_and_architecture_comparison.access_methods[2]][14] |
| **Custom Data** | Arbitrary NBT stored in the `minecraft:custom_data` component on items. [data_model_and_architecture_comparison.primary_system[1]][6] | Managed via **Dynamic Properties** in the Script API. [data_model_and_architecture_comparison[5]][13] |
| **Persistence** | NBT on entities/blocks is saved with the world. `/data storage` provides a persistent global key-value store. [data_model_and_architecture_comparison.persistence_model[1]][1] | Entity Properties are always persisted. Dynamic Properties are saved to the world's LevelDB and survive restarts. [data_model_and_architecture_comparison.persistence_model[0]][13] |
| **Client Sync** | Mostly implicit. No generic flag to sync arbitrary server-side entity data for rendering. | Explicit via `"client_sync": true` on an Entity Property, making it available to Molang for animations. [data_model_and_architecture_comparison.client_synchronization[0]][4] |

### 1.2 Why It Matters for Logic, Performance, and Security

Java's "arbitrary access" model grants immense power and flexibility to command-based creators, enabling complex logic and state machines without ever leaving `.mcfunction` files. The downside is that it's potentially fragile; a change in vanilla NBT structure can silently break a data pack. The 1.20.5 component system is a direct response to this, aiming to improve performance and data integrity by validating properties at load time. [data_model_and_architecture_comparison[8]][7]

Bedrock's "structured access" model is intentionally more restrictive. By forcing creators to work through defined components and APIs, it ensures data is always in a valid state, which is critical for performance and stability across a wide range of devices, from consoles to mobile phones. This trades some of the raw command-line power of Java for greater reliability and better integration between server-side logic and client-side visuals.

## 2. Pack Structure & Versioning Minefields

The way content packs are structured, versioned, and loaded is a major source of friction when porting between editions or even between minor updates of the same edition. A single misplaced file or incorrect version number can cause an entire pack to be rejected by the game.

### 2.1 Java 1.21 Folder Renames & Overlay Fix Patterns

A major breaking change in **Java 1.21** was the renaming of several key data pack directories from plural to singular to better align with their registry names. [java_edition_version_changelog[29]][15] [java_edition_version_changelog[43]][16] This affects nearly every data pack.

**Key Directory Changes (1.20.x → 1.21+):**
* `functions/` → `function/`
* `loot_tables/` → `loot_table/`
* `recipes/` → `recipe/`
* `advancements/` → `advancement/`
* `predicates/` → `predicate/`
* `structures/` → `structure/`

To support both pre- and post-1.21 versions in a single pack, the most robust strategy is to use the **`overlays`** feature in `pack.mcmeta`, introduced in 1.20.2. [java_edition_version_changelog[35]][17] This allows you to define sub-directories that are conditionally applied based on the game's pack format, letting you maintain both the old and new folder structures in one download.

### 2.2 Bedrock's `min_engine_version` as a Feature Toggle

Bedrock Edition uses a mandatory `manifest.json` file for both Behavior and Resource Packs. [pack_formats_and_file_structures.metadata_file[0]][18] Compatibility is controlled by the `min_engine_version` field in the header, which specifies the minimum game version required (e.g., `[1, 20, 0]`). [pack_formats_and_file_structures.versioning_mechanism[0]][19]

This field is not just metadata; it acts as a crucial **feature gate**. For example, to use the modern `/execute` command syntax, your pack's `manifest.json` must declare a `min_engine_version` of at least **1.19.70**. [command_parity_execute.syntax_parity_status[0]][10] Declaring a lower version will cause commands using the new syntax to fail.

### 2.3 Java's New `min_format` and `max_format`

As of Java 1.21.9 (snapshot 25w31a), the versioning system in `pack.mcmeta` was overhauled. The old `pack_format` and `supported_formats` fields were deprecated and replaced by two new required fields: `min_format` and `max_format`. [java_edition_version_changelog[0]][20] [java_edition_version_changelog[5]][21] This allows a single pack to declare a precise, inclusive range of compatible game versions, simplifying maintenance for creators who need to support multiple minor updates. [pack_formats_and_file_structures.versioning_mechanism[0]][19]

## 3. Command Surface—Where Parity Ends

While recent updates have brought the command syntax of the two editions closer, significant functional gaps remain. Assuming a command with the same name works the same way is a common and costly porting mistake.

### 3.1 `/execute` Capability Matrix: Syntax Parity vs. Feature Parity

Bedrock Edition received a major `/execute` overhaul in version **1.19.50**, adopting the modern, chainable Java-style syntax. [command_parity_execute.syntax_parity_status[0]][10] However, this created a state of "syntax parity" without "feature parity." Many of Java's most powerful subcommands and conditions are missing in Bedrock.

| Subcommand / Condition | Java Edition (1.21+) | Bedrock Edition (1.21+) | Porting Implication |
| :--- | :--- | :--- | :--- |
| **`store result/success`** | **Yes**. Core for dynamic logic. | **No**. [command_parity_execute.missing_subcommands_in_bedrock[0]][10] | Major blocker. Logic must be moved to Script API to capture and use command results. |
| **`if/unless data`** | **Yes**. For checking any NBT. | **No**. [command_parity_execute.missing_conditions_in_bedrock[0]][10] | Impossible to port directly. Use Entity Properties, filters, or Script API checks instead. |
| **`if/unless predicate`** | **Yes**. For reusable JSON logic. | **No**. [command_parity_execute.missing_conditions_in_bedrock[0]][10] | Logic must be rebuilt using Behavior Pack filters or Script API functions. |
| **`if/unless score`** | **Yes**. Full range and comparison. | **Yes**. Functionally similar. | High compatibility. Safe to use for cross-edition logic. |
| **`if/unless block(s)`** | **Yes**. | **Yes**. | High compatibility. |
| **`if/unless entity`** | **Yes**. | **Yes**. | High compatibility. |
| **`on`** (attacker, vehicle, etc.) | **Yes** (since 1.19.4). | **No**. | Context switching must be done manually with selectors or via Script API events. |
| **`summon`** | **Yes** (since 1.19.4). | **No**. | Must use a separate `/summon` command; cannot chain context. |

### 3.2 Data Introspection: `/data`, `/storage`, and Bedrock's Alternatives

Java Edition's data introspection capabilities are centered on the `/data` command, which is **exclusive to Java**. [command_parity_data_introspection.java_capabilities[0]][1] It allows for full CRUD (Create, Read, Update, Delete) operations on the NBT of any entity, block entity, or a persistent global key-value store called command `storage`. [command_parity_data_introspection.java_capabilities[0]][1]

Bedrock Edition has **no direct equivalent**. Instead, creators must use a combination of structured systems:
* **Entity Properties:** For predefined, checkable states on entities.
* **Dynamic Properties:** For arbitrary, script-managed data persistence. [data_model_and_architecture_comparison[5]][13]
* **Behavior Pack Filters & Molang:** For conditional logic within JSON files. [conditional_logic_systems.primary_system[0]][4]

### 3.3 Scheduling & Automation Divergence: `/schedule`

The `/schedule` command exists in both editions but serves fundamentally different purposes.
* **Java:** `/schedule function <function> <time>` is a robust, time-based scheduler, allowing delays in ticks, seconds, or days. [function_and_automation_systems[7]][22] It is persistent and essential for timed event systems.
* **Bedrock:** The primary use is `schedule on_area_loaded`, which queues a function to run when a specific area is loaded. [function_and_automation_systems.scheduled_execution[0]][22] It is a location-based trigger, not a general-purpose timer. The intended workaround for timed delays in Bedrock is the Script API's `system.runTimeout()` and `system.runInterval()` functions.

## 4. Item Componentization & Runtime Mutation

The most significant technical change in the 1.20 era was Java's migration to an item component system, bringing it conceptually closer to Bedrock's long-standing model but with critical implementation differences.

### 4.1 The Great Migration: Java 1.20.5 Replaces NBT with Components

In version **1.20.5**, Java Edition replaced the unstructured NBT `tag` on item stacks with a system of structured, typed, and validated components. [item_componentization_and_mutation.primary_change_or_pattern[0]][7] This was a major breaking change designed to improve performance and data integrity. [data_model_and_architecture_comparison[8]][7] Any custom data that was previously stored in the `tag` is automatically migrated to the new `minecraft:custom_data` component. [item_componentization_and_mutation.custom_data_handling[0]][7]

In Bedrock, custom items have always been defined this way: as a collection of `minecraft:` components in a Behavior Pack JSON file. [data_model_and_architecture_comparison[39]][12]

### 4.2 Command Syntax Refactor Playbook

This migration required a complete overhaul of command syntax in Java. The old syntax using curly braces (`{...}`) was removed. [item_componentization_and_mutation.command_syntax[0]][7]

**Java Command Syntax: Before and After 1.20.5**
```mcfunction
# Old Syntax (pre-1.20.5)
/give @s diamond_sword{display:{Name:'"Epic Sword"'},Enchantments:[{id:"sharpness",lvl:5}]}

# New Syntax (1.20.5+)
/give @s diamond_sword[item_name='"Epic Sword"',enchantments={levels:{"sharpness":5}}]
```

**Bedrock Command Pattern**
In Bedrock, while `/give` has a `components` argument, it's limited. The standard pattern is to define the item in a JSON file and give it by its custom identifier.
```json
// In my_items/custom_sword.json
{
 "format_version": "1.20.80",
 "minecraft:item": {
 "description": { "identifier": "wiki:custom_sword" },
 "components": {
 "minecraft:display_name": { "value": "Epic Sword" },
 "minecraft:enchantable": { "value": 10, "slot": "sword" }
 }
 }
}
mcfunction
# In-game command
/give @s wiki:custom_sword
```

### 4.3 Runtime Mutation Methods

How you change an item's properties during gameplay also differs:
* **Java:** The primary method is the `/item modify` command, which applies a predefined item modifier (a loot function) to an item in an inventory. [java_edition_version_changelog[21]][23] Functions like `set_custom_data` are used to manipulate the `minecraft:custom_data` component.
* **Bedrock:** Runtime mutation is handled almost exclusively by the **Script API**. Scripts listen for game events (e.g., `itemUse`) and can then access an inventory to modify an `ItemStack`'s dynamic properties or trigger events that change its component groups. [item_componentization_and_mutation.runtime_mutation_method[0]][7]

## 5. Logic Engines—Functions, Macros, and Scripts

The tools for creating reusable and dynamic logic have evolved significantly, but on separate tracks.

### 5.1 Java's Advanced Functions: Macros and `/return`

Java Edition has introduced two powerful features for function authors:
* **Macro Functions (1.20.2):** This feature allows for function templating. By prefixing lines with a `$` and using `$(variable)` placeholders, you can pass arguments to a function, enabling dynamic command generation. [function_and_automation_systems.advanced_features[0]][24]
* **`/return` Command (1.20 snapshots):** Added in snapshot 23w16a, `/return` allows a function to stop execution and set a specific return value, which can be captured by `/execute store`. [function_and_automation_systems.advanced_features[1]][25] This is crucial for creating functions that report results.

### 5.2 Bedrock's Script API: The Ultimate Logic Engine

Bedrock's advanced logic capabilities are centered on its **Script API**. Instead of command-based templating, it offers a full JavaScript/TypeScript environment. Key features that replace or exceed Java's function capabilities include:
* **Event-Driven Logic:** Scripts can subscribe to a huge array of game events to trigger complex logic.
* **Custom Commands:** Scripts can register their own custom slash commands with typed parameters, extending the game's command system in ways not possible in Java. [java_edition_version_changelog[4]][26]
* **Timed Execution:** As a replacement for `/schedule`, the API provides `system.runTimeout()` for one-time delays and `system.runInterval()` for recurring tasks.

### 5.3 Command Chain Limits & Performance Guardrails

Both editions impose limits to prevent server-crashing loops.
* **Bedrock Edition:** Has a hard limit of **10,000 commands** per function call, inclusive of any nested functions. [engine_constraints_and_performance_limits.bedrock_edition_details[0]][27] This is controlled by the `functioncommandlimit` gamerule.
* **Java Edition:** Uses the `maxCommandChainLength` gamerule, which defaults to **65,536**. [engine_constraints_and_performance_limits.java_edition_details[0]][24] This limits the total commands executed from a single root source (like a tick function) in one tick.

## 6. Conditional Systems—Predicates, Filters, and Molang

How you ask "if this, then that" is a major point of divergence.

| System | Java Edition | Bedrock Edition |
| :--- | :--- | :--- |
| **Primary System** | **JSON Predicates**: Reusable logic files in `data/<namespace>/predicate/` invoked with `/execute if predicate <id>`. [conditional_logic_systems.primary_system[1]][28] | **Behavior Pack Filters**: JSON objects used in entity events, spawn rules, etc., with `all_of`, `any_of`, `none_of` logic gates. [conditional_logic_systems.primary_system[0]][4] |
| **Data Checking** | `/execute if data`: Checks for arbitrary NBT on entities, blocks, or storage. [conditional_logic_systems.data_checking_method[0]][1] | **Entity/Dynamic Properties**: Checks for predefined, typed properties using filters like `has_property` or `bool_property`. [conditional_logic_systems.data_checking_method[1]][4] |
| **Numerical Checking** | `/execute if score`: The primary method for checking scoreboard values. | `/execute if score` plus **Entity Properties** of type `int` or `float`, which can be checked with filters and modified with Molang. [conditional_logic_systems.numerical_checking_method[0]][4] |
| **Expression Language** | None (logic is command-based). | **Molang**: An expression language embedded in JSON to query game state (`q.is_sneaking`) for animations and rendering. [conditional_logic_systems.primary_system[3]][3] |
| **Ultimate Tool** | Complex combinations of predicates and `/execute store` workflows. | **Script API**: Full JavaScript/TypeScript control flow (`if`, `switch`, loops) and access to all game state. [conditional_logic_systems.scripting_integration[0]][3] |

## 7. Data-Driven Registries & Worldgen Opportunities

A key trend in recent Java updates is making more of the game's content "data-driven," allowing creators to add new things without mods.

### 7.1 Java 1.21's New Data-Driven Content

Java 1.21 made several systems fully data-driven via Data Packs:
* **Paintings (`painting_variant`):** Creators can add new paintings by defining their `asset_id`, `width`, and `height` in a JSON file. [data_driven_registries_and_worldgen.newly_data_driven_in_java[0]][29]
* **Jukebox Songs (`jukebox_song`):** Custom music discs can be created by defining a song's `sound_event`, `description`, and `length_in_seconds`, then applying the `minecraft:jukebox_playable` component to an item.
* **Enchantments (`enchantment`):** Enchantments are now data-driven, with custom behaviors and exclusivity rules managed through data pack files and tags. [data_driven_registries_and_worldgen.newly_data_driven_in_java[1]][30] [data_driven_registries_and_worldgen.newly_data_driven_in_java[3]][31]

Bedrock Edition does not have direct, simple parallels for adding these specific content types; similar results would require more complex workarounds involving resource pack swaps and script-driven logic.

### 7.2 World Generation Customization

Both editions feature data-driven world generation, but with different architectures.
* **Java Edition:** Worldgen is deeply customized via Data Packs, with JSON files in the `data/<namespace>/worldgen/` folder controlling biomes, terrain shape (`noise_settings`), features (`configured_feature`), and complex structures (`structure_set`, `template_pool`). [data_driven_registries_and_worldgen.worldgen_customization[0]][32]
* **Bedrock Edition:** Worldgen is customized via Behavior Packs. Biomes are defined with components like `minecraft:climate`, features are defined in `features/*.json`, and complex Jigsaw structures are also supported, using `.mcstructure` files.

## 8. Redstone & Simulation Variance

Redstone is the source of some of the most well-known and irreconcilable differences between the editions. Mojang has stated they do not intend to unify these behaviors.

### 8.1 The Quasi-Connectivity Divide

**Java Edition has quasi-connectivity (QC)**, a behavior where components like pistons can be activated by a power source that is not directly adjacent (e.g., diagonally above). [redstone_and_simulation_differences.quasi_connectivity[1]][33] This is a core mechanic for many advanced circuits. **Bedrock Edition does not have QC**; components must be powered directly. [redstone_and_simulation_differences.quasi_connectivity[0]][34] This single difference makes many compact Java designs impossible on Bedrock.

### 8.2 Piston Inconsistencies

Piston behavior differs dramatically:
* **Block Spitting:** Java sticky pistons can "spit" their block if given a 1-redstone-tick pulse. Bedrock pistons cannot, always pulling the block back. [redstone_and_simulation_differences.piston_behavior[0]][34]
* **Pushing Tile Entities:** Bedrock pistons **can** push tile entities like chests and furnaces. Java pistons cannot.
* **Timing:** Java pistons have a variable activation delay, enabling "0-tick" designs. Bedrock pistons have a fixed 2-game-tick delay for both extension and retraction.

### 8.3 Update Order: Deterministic vs. Random

**Java Edition has a deterministic, locational update order.** When multiple components are triggered in the same tick, they always update in the same predictable sequence. [redstone_and_simulation_differences.update_order_and_timing[0]][34] **Bedrock Edition has a random, non-deterministic update order,** making timing-sensitive circuits unreliable. This is partly due to Bedrock's two-phase tick system, which separates when outputs are calculated and when components react.

## 9. Version-by-Version Breaking Changes Tracker

| Edition | Version | Release Date | Key Creator Features | Breaking Changes & Migration Path |
| :--- | :--- | :--- | :--- | :--- |
| **Java** | 1.20.2 | 2023-09-21 | **Function Macros**, `/random` command, Command line continuation, `supported_formats` in `pack.mcmeta`. [java_edition_version_changelog.key_creator_features[0]][35] | Experimental `return run` removed. Mob effect IDs became string-based. |
| **Java** | 1.20.5 | 2024-04-23 | **Item Components System**, new command syntax (`item[...]`), `execute if items` command. [java_edition_version_changelog.key_creator_features[0]][35] | **Major Break:** All item NBT `tag` data must be migrated to the `minecraft:custom_data` component. All item commands must be rewritten. Pack formats updated. [java_edition_version_changelog.breaking_changes_and_migration[0]][20] |
| **Java** | 1.21 | 2024-06-13 | Data-driven Enchantments, Paintings, Wolf Variants. `@n` selector. `!` prefix to remove default components. [java_edition_version_changelog.key_creator_features[0]][35] | **Major Break:** Data pack directories renamed to singular (e.g., `functions` -> `function`). Packs must be restructured. Pack formats updated. [java_edition_version_changelog.breaking_changes_and_migration[0]][20] |
| **Java** | 1.21.9 | 2025-09-30 | Server Management Protocol (JSON-RPC), `/datapack create`, `/version` commands, GameTests in data packs. [java_edition_version_changelog.key_creator_features[0]][35] | **Major Break:** `pack.mcmeta` overhauled. `pack_format` and `supported_formats` replaced by required `min_format` and `max_format` fields. [java_edition_version_changelog.breaking_changes_and_migration[0]][20] [java_edition_version_changelog.breaking_changes_and_migration[1]][17] |
| **Bedrock** | 1.19.50 | Late 2022 | Stabilized modern, Java-like `/execute` syntax. [bedrock_edition_version_changelog.key_creator_features[3]][10] | New `/execute` syntax became mandatory for packs with `min_engine_version` of 1.19.70+. [bedrock_edition_version_changelog.deprecations_and_migrations[0]][36] |
| **Bedrock** | 1.21.20 | 2024-08-13 | **Stable Custom Components** for blocks and items. [bedrock_edition_version_changelog.key_creator_features[0]][9] | **Major Break:** 'Holiday Creator Features' toggle removed. Content must be migrated to Custom Components. Entity Permutations and `/volumearea` deprecated. [bedrock_edition_version_changelog.deprecations_and_migrations[3]][8] |
| **Bedrock** | 1.21.40 | 2024-10-22 | `/schedule` overloads, `/locate` identifier output, several APIs moved to stable. [bedrock_edition_version_changelog.key_creator_features[0]][9] | **Breaking:** Stricter JSON parsing for `minecraft:item` (no more interchangeable numbers/booleans). `biomes_client.json` removed. `BlockLiquidContainerComponents` API replaced. [bedrock_edition_version_changelog.deprecations_and_migrations[0]][36] |
| **Bedrock** | 1.21.120 | 2025-10-28 | More APIs moved to stable (Light Detection, Biome API). Manifests can use `"beta"` for dependency versions. New entity goals. [bedrock_edition_version_changelog.key_creator_features[0]][9] | **Breaking:** Stricter schema parsing for several AI goal behaviors. Entity packs with invalid definitions will fail to load. [bedrock_edition_version_changelog.deprecations_and_migrations[0]][36] |

## 10. Porting Playbooks—Common Scenarios Solved

Translating content from Java to Bedrock is less about a 1:1 conversion and more about mapping concepts to different architectural patterns.

### Creator Goal: Create a stateful entity with custom data (e.g., mana, charge, quest stage). [cross_edition_porting_playbook.creator_goal[0]][2] [cross_edition_porting_playbook.creator_goal[1]][37]

* **Java Edition Pattern:** Use a combination of built-in systems. Scoreboards are ideal for numerical data (`/scoreboard players set @s mana 100`). Entity tags are used for boolean flags (`/tag @s add is_charged`). For complex structured data, manipulate the `minecraft:custom_data` component via `/data modify`. [cross_edition_porting_playbook.java_edition_pattern[0]][2] Logic is handled in `.mcfunction` files using conditional `/execute` commands. [cross_edition_porting_playbook.java_edition_pattern[1]][1]
* **Bedrock Edition Pattern:** Center the design on the Add-On architecture. For dynamic data like 'mana', use the Script API to manage persistent **Dynamic Properties** (`entity.setDynamicProperty('mana', 100)`). For simpler, predefined states like 'enraged', define custom **Entity Properties** (`bool`, `int`, etc.) in the entity's behavior JSON. [cross_edition_porting_playbook.bedrock_edition_pattern[1]][37] Logic is then implemented in the Script API by listening to game events and modifying these properties.
* **Translation Summary:** A Java scoreboard value or NBT tag translates into a Bedrock Dynamic Property managed by a script. A Java `/tag` maps to a boolean Dynamic Property or a defined `bool` Entity Property. The core logic must be rewritten: a Java command-based state machine becomes a conditional `if/else` block in a JavaScript function that checks the property's value. [cross_edition_porting_playbook.translation_summary[0]][37] This shifts the implementation from a purely command-driven system to a script-driven one.

## 11. Testing & CI for Zero-Day Compatibility

With the increasing pace of technical updates and breaking changes, automated testing has become essential for professional creators.

### 11.1 In-Game Automated Testing Tools

Both editions now offer a native **GameTest Framework** for running automated, in-game tests.
* **Java Edition:** As of 1.21.5 (snapshot 25w03a), the GameTest Framework is accessible via data packs. Creators can define test environments and instances in their pack to script and run tests without mods.
* **Bedrock Edition:** Features a mature GameTest Framework accessible via the `@minecraft/server-gametest` script module. [testing_and_distribution_strategies.bedrock_edition_tools_and_methods[0]][38] Tests are written in JavaScript/TypeScript and provide a rich library of assertion functions (`assertBlockPresent`, `assertEntityState`, etc.) to validate game mechanics. [testing_and_distribution_strategies.bedrock_edition_tools_and_methods[1]][39]

### 11.2 A Modern Continuous Integration (CI) Pattern

A CI pipeline (e.g., using GitHub Actions) can automate validation and prevent broken content from being released.
1. **Trigger:** Runs on every commit or pull request.
2. **Static Analysis:** Linters and schema validators catch syntax errors early.
3. **Build:** Compiles source files into the final pack(s).
4. **Test Execution:** Spins up a dedicated server in a Docker container, loads the pack, and runs all GameTests on startup.
5. **Result Parsing:** A script parses the server logs for GameTest success or failure messages.
6. **Status Report:** The pipeline job succeeds or fails based on the test results, providing immediate feedback.

## 12. Action Roadmap & Resource Toolkit

Navigating the Java-Bedrock divide requires a strategic approach. This roadmap prioritizes tasks for creators managing cross-edition content.

**Immediate Actions (Next 30 Days):**
1. **Audit for Java 1.21 Directory Renames:** Identify all data packs and implement a build step or `overlays` structure to support both plural and singular directory names.
2. **Migrate from Holiday Creator Features:** For any Bedrock packs still using this experimental toggle, begin the migration to stable Custom Components immediately, as they are now broken in version 1.21.20+.
3. **Refactor Java 1.20.5 Item Commands:** Systematically update all commands that give or modify items to use the new component syntax (`item[...]`) and move custom data to `minecraft:custom_data`.

**Mid-Term Strategy (Next 3-6 Months):**
1. **Implement CI with GameTests:** Set up a basic CI pipeline to run static analysis and GameTests on every pull request. This will dramatically reduce regressions and hotfix cycles.
2. **Abstract Core Logic:** Identify complex logic currently implemented in Java commands (especially those using `/execute store`) and create parallel implementations in the Bedrock Script API.
3. **Develop Edition-Specific Redstone:** Formally adopt a policy of building separate redstone contraptions for each edition. Forbid the use of QC-dependent designs in any project intended for Bedrock.

**Long-Term Vision (2025-2026):**
1. **Build a Component/Property Library:** Create a shared library of common Bedrock Entity Properties and Script API functions to standardize state management across projects.
2. **Explore New Data-Driven Opportunities:** Plan Java-first cosmetic DLCs that leverage the new data-driven painting, song, and enchantment registries.
3. **Future-Proof Pack Metadata:** Adopt the new `min_format`/`max_format` schema for all new Java packs and establish a clear process for updating it with each minor release.

## References

1. *Commands/data - Minecraft Wiki - Fandom*. https://minecraft.fandom.com/wiki/Commands/data
2. *Data component format*. https://minecraft.wiki/w/Data_component_format
3. *Entity Properties - Bedrock Wiki*. https://wiki.bedrock.dev/entities/entity-properties
4. *Introduction to Entity Properties*. https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoentityproperties?view=minecraft-bedrock-stable
5. *Script Core Features | Bedrock Wiki*. https://wiki.bedrock.dev/scripting/script-server
6. *Java Edition 1.20.5*. https://minecraft.wiki/w/Java_Edition_1.20.5
7. *Minecraft Java Edition 1.20.5*. https://www.minecraft.net/en-us/article/minecraft-java-edition-1-20-5
8. *Removal of Holiday Creator Features in Minecraft PE and ...*. https://www.facebook.com/groups/addonsmakerminecraft/posts/1535449850741083/
9. *Minecraft Bedrock 1.21 Update Notes for Creators*. https://learn.microsoft.com/pt-pt/minecraft/creator/documents/update1.21?view=minecraft-bedrock-stable
10. *New execute command support in Minecraft version 1.19.70*. https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsnewexecute?view=minecraft-bedrock-stable
11. *NBT format*. https://minecraft.wiki/w/NBT_format
12. *Item Components | Bedrock Wiki*. https://wiki.bedrock.dev/items/item-components
13. *Dynamic Properties | JaylyMC*. https://jaylydev.github.io/scriptapi-docs/features/dynamic-properties.html
14. *minecraft/server.Entity Class*. https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/entity?view=minecraft-bedrock-stable
15. *Minecraft Snapshot 24w21b*. https://www.minecraft.net/en-us/article/minecraft-snapshot-24w21a
16. *Minecraft 24w21a - Changes and metadata*. https://misode.github.io/versions/?id=24w21a
17. *pack.mcmeta*. https://minecraft.wiki/w/Pack.mcmeta
18. *Pack format*. https://minecraft.wiki/w/Pack_format
19. *Tutorial:Creating a data pack*. https://minecraft.wiki/w/Tutorial:Creating_a_data_pack
20. *Java Edition 1.21.9*. https://minecraft.wiki/w/Java_Edition_1.21.9
21. *Minecraft Java Edition 1.21.9*. https://www.minecraft.net/en-us/article/minecraft-java-edition-1-21-9
22. *schedule*. https://minecraft.wiki/w/Commands/schedule
23. *Commands/item - Minecraft Wiki - Fandom*. https://minecraft.fandom.com/wiki/Commands/item
24. *Function (Java Edition)*. https://minecraft.wiki/w/Function_(Java_Edition)
25. *Minecraft Snapshot 23w16a*. https://www.minecraft.net/en-us/article/minecraft-snapshot-23w16a
26. *Scripting Custom Commands*. https://learn.microsoft.com/en-us/minecraft/creator/documents/scripting/custom-commands?view=minecraft-bedrock-stable
27. *Function (Bedrock Edition) - Minecraft Wiki - Fandom*. https://minecraft.fandom.com/wiki/Function_(Bedrock_Edition)
28. *Predicate - Minecraft Wiki*. https://minecraft.wiki/w/Predicate
29. *Painting variant definition*. https://minecraft.wiki/w/Painting_variant_definition
30. *Java Edition 1.21*. https://minecraft.wiki/w/Java_Edition_1.21
31. *Enchantment provider*. https://minecraft.wiki/w/Enchantment_provider
32. *Custom world generation - Minecraft Wiki - Fandom*. https://minecraft.fandom.com/wiki/Custom_world_generation
33. *Tutorial:Quasi-connectivity*. https://minecraft.wiki/w/Tutorial:Quasi-connectivity
34. *Differences between Minecraft Bedrock Edition and ...*. https://learn.microsoft.com/en-us/minecraft/creator/documents/differencesbetweenbedrockandjava?view=minecraft-bedrock-stable
35. *Minecraft 1.20.5: Patch Notes & Features to Try*. https://www.meloncube.net/blog/minecraft-1-20-5-patch-notes-features-to-try/
36. *1.19.50 Update Available on Bedrock*. https://www.minecraft.net/en-us/article/1-19-50-update-available-bedrock
37. *Entities Documentation | bedrock. ...*. https://bedrock.dev/docs/stable/Entities
38. *Script API Reference Documentation*. https://learn.microsoft.com/gl-es/minecraft/creator/scriptapi/
39. *Intro to Scripting | Bedrock Wiki*. https://wiki.bedrock.dev/scripting/scripting-intro